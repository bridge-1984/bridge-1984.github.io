(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{403:function(v,_,t){"use strict";t.r(_);var a=t(1),e=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"什么是-http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-http"}},[v._v("#")]),v._v(" 什么是 HTTP")]),v._v(" "),_("h3",{attrs:{id:"概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),_("p",[v._v("HTTP（HyperText Transfer Protocol）即超文本运输协议，是实现网络通信的一种规范。常被用于在web浏览器和网站服务器之间传递信息，"),_("strong",[v._v("以明文传递内容")]),v._v("，不进行任何加密。默认端口号为 80。")]),v._v(" "),_("h3",{attrs:{id:"http-特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-特点"}},[v._v("#")]),v._v(" HTTP 特点")]),v._v(" "),_("ol",[_("li",[v._v("支持客户端/服务器模式")]),v._v(" "),_("li",[v._v("简单快速")]),v._v(" "),_("li",[v._v("灵活：http 允许传输任何类型的数据类型，用 content-type 标记正在传输的类型。")]),v._v(" "),_("li",[v._v("无连接：每次连接只处理一个请求，请求完成后即断开 tcp 连接。每一个请求都要重新建立 TCP 连接（"),_("strong",[v._v("1.0 版本")]),v._v("）")]),v._v(" "),_("li",[v._v("无状态：http 协议无法根据上一次连接的状态进行本次的请求处理")])]),v._v(" "),_("h2",{attrs:{id:"http-1-0-1-1-2-0-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-1-1-2-0-的区别"}},[v._v("#")]),v._v(" HTTP 1.0/1.1/2.0 的区别")]),v._v(" "),_("h3",{attrs:{id:"http-1-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[v._v("#")]),v._v(" HTTP 1.0")]),v._v(" "),_("p",[v._v("浏览器只和服务器保持短暂的连接，每次发起请求时都需要和服务器建立 TCP 连接，服务器完成请求处理后立即断开连接。"),_("br"),v._v("\n要建立起长连接，需要设置一个非标准的 Connection 字段："),_("code",[v._v("Connection: keep-alive")])]),v._v(" "),_("h3",{attrs:{id:"http-1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[v._v("#")]),v._v(" HTTP 1.1")]),v._v(" "),_("ul",[_("li",[v._v("HTTP 1.1 支持长连接且默认开启，从而一个 TCP 连接可以发起多个 HTTP 请求，减少了建立和关闭连接的消耗和延迟。")]),v._v(" "),_("li",[v._v("持续化连接使多数请求以管线化方式发送成为可能。之前发送请求需要等待并得到响应后，才可以发送下一个请求，而使用管道化技术后可以不用等待响应而直接发送下一个请求。")]),v._v(" "),_("li",[v._v("新增了请求方式："),_("code",[v._v("OPTION")]),v._v("、 "),_("code",[v._v("TRACE")]),v._v("、 "),_("code",[v._v("CONNECT")])]),v._v(" "),_("li",[v._v("增加了更多的请求头和响应头来完善功能：\n"),_("ol",[_("li",[v._v("引入了更多的缓存控制策略，如 "),_("code",[v._v("If-Unmodified-Since")]),v._v(",  "),_("code",[v._v("If-Match")]),v._v(", "),_("code",[v._v("If-None-Match")]),v._v("等缓存头来控制缓存策略")]),v._v(" "),_("li",[v._v("引入 "),_("code",[v._v("range")]),v._v("，允许值请求资源某个部分")]),v._v(" "),_("li",[v._v("引入 "),_("code",[v._v("host")]),v._v("，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点")])])])]),v._v(" "),_("h3",{attrs:{id:"http-2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[v._v("#")]),v._v(" HTTP 2.0")]),v._v(" "),_("p",[_("strong",[v._v("多路复用")]),_("br"),v._v("\n在一次 TCP 连接中，客户端和服务器都可以并发发送多个请求或回应，而不用按顺序一一对应")]),v._v(" "),_("p",[_("strong",[v._v("二进制分帧")]),_("br"),v._v("\nHTTP 2.0 采用二进制格式传输数据，而非之前的文本格式，解析速度更快")]),v._v(" "),_("p",[_("strong",[v._v("首部压缩")]),_("br"),v._v("\nHTTP 2.0 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送。"),_("br"),v._v("\n例如有两个请求，请求一发送了所有的头部信息，而请求二只需要发送差异部分的信息即可")]),v._v(" "),_("p",[_("strong",[v._v("服务器推送")]),_("br"),v._v("\nHTTP 2.0 允许服务端推送数据给客户端。"),_("br"),v._v("\n当客户端请求一个页面时，服务器可顺带推送用户需要的其他资源，减少客户端发起请求的次数")]),v._v(" "),_("h2",{attrs:{id:"http-缓存控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存控制"}},[v._v("#")]),v._v(" HTTP 缓存控制")]),v._v(" "),_("h3",{attrs:{id:"概念-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概念-2"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),_("p",[v._v("浏览器缓存是浏览器在本地磁盘对用户最近请求的文档进行缓存，当用户再次发起对该文档资源的请求时，浏览器可以从磁盘直接读取对应资源。缓存主要分为"),_("strong",[v._v("强缓存")]),v._v("和"),_("strong",[v._v("协商缓存")])]),v._v(" "),_("h3",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),_("p",[_("strong",[v._v("1. 特点:")]),v._v(" 直接从本地副本比较读取，而不需要请求服务器，命中时返回的状态码是 200"),_("br"),v._v(" "),_("strong",[v._v("2. 控制的字段")])]),v._v(" "),_("ul",[_("li",[v._v("Expires"),_("br"),v._v(" "),_("code",[v._v("Expires")]),v._v(" 是 HTTP/1.0 中定义的缓存字段，其值是一个 GMT 格式的时间。当我们发起一个请求，服务器返回时，可以在回复的头部（Response Headers）增加 "),_("code",[v._v("Expires")]),v._v(" 字段表明资源的过期时间。当客户端再次发起同一请求时，会将客户端时间与该时间进行比较，小于则证明缓存未过期，直接从磁盘读取。")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("expires: Sun, 04 Sep 2022 10:30:48 GMT\n")])])]),_("p",[_("strong",[v._v("缺点：")]),v._v(" 客户端时间和服务器时间不一定统一，并且用户可以更改自己客户端的时间")]),v._v(" "),_("ul",[_("li",[v._v("Cache-Control\n"),_("code",[v._v("Cache-Control")]),v._v(" 是 HTTP/1.1 进行缓存控制的字段，其值有：\n"),_("ul",[_("li",[_("code",[v._v("max-age=xxx")]),v._v("：表示缓存离过期还有多少秒")]),v._v(" "),_("li",[_("code",[v._v("public")]),v._v("：可以被所有用户缓存")]),v._v(" "),_("li",[_("code",[v._v("private")]),v._v("：只能被客户端缓存")]),v._v(" "),_("li",[_("code",[v._v("no-cache")]),v._v("：不使用强缓存，但可以使用协商缓存")]),v._v(" "),_("li",[_("code",[v._v("no-store")]),v._v("：所有内容都不会被缓存，既不能使用强缓存，也不使用协商缓存，即每个请求都需要完整下载资源")])])])]),v._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),_("ul",[_("li",[v._v("Last-Modified / If-Modified-Since"),_("br"),v._v(" "),_("code",[v._v("Last-Modified")]),v._v(" 是第一次发起请求时，返回该资源在服务器最后一次修改的时间"),_("br"),v._v("\n再次发起同一请求时，会带上 "),_("code",[v._v("If-Modified-Since")]),v._v(" 字段，其值等于上次返回的 "),_("code",[v._v("Last-Modified")]),v._v("。服务器通过对比该字段的值和该资源在服务器最后修改的时间，如果修改时间晚于 "),_("code",[v._v("If-Modified-Since")]),v._v(",返回200；否则命中缓存，返回304，代表资源没更新。")])]),v._v(" "),_("p",[_("strong",[v._v("缺点：")])]),v._v(" "),_("ol",[_("li",[v._v("资源只要编辑了，不管内容是否有变，修改时间都会更新")]),v._v(" "),_("li",[v._v("时间的精确度只能到秒，即一秒内的修改是监测不到更新的，仍会使用旧的缓存")])]),v._v(" "),_("ul",[_("li",[v._v("Etag / If-None-Match"),_("br"),v._v(" "),_("code",[v._v("Etag")]),v._v(" 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）"),_("br"),v._v(" "),_("code",[v._v("If-None-Match")]),v._v(" 是客户端再次发起请求时，携带上次请求返回的唯一标识Etag值，服务端收到该请求后，发现该请求含有 "),_("code",[v._v("If-None-Match")]),v._v("，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件，否则重新返回资源，状态码为200")])]),v._v(" "),_("h3",{attrs:{id:"应用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[v._v("#")]),v._v(" 应用场景")]),v._v(" "),_("ul",[_("li",[v._v("对于 HTML 这种包含了其他文件的主要文件，为了确保当其内容修改时页面能够及时地更新，一般直接使用协商缓存，即为 cache-control 增加   "),_("code",[v._v("no-cache")]),v._v(" 属性值")]),v._v(" "),_("li",[v._v("对于图片文件这种，一般修改都是直接改变链接，所以可以直接采取强缓存，同时由于图片的数量和大小一般较大，可能会占用较多的客户端缓存，所以也不宜设置时间过长，可设置为 "),_("code",[v._v("max-age = 86400")])]),v._v(" "),_("li",[v._v("对于样式、js脚本等文本文件，如果内容不会定期更新，可以考虑在命名时加上版本号，然后使用强缓存并可以设置一个较长的时间。这样既能使用强缓存提高重用效率，又因为修改后版本号不同，即文件 URL 改变了，不需要再进行缓存的判断，而可以直接发起 http 请求获取最新的资源")])]),v._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("ol",[_("li",[v._v("对于强缓存，"),_("code",[v._v("Cache-Control")]),v._v(" 优先级高于 "),_("code",[v._v("Expires")])]),v._v(" "),_("li",[v._v("对于协商缓存，"),_("code",[v._v("Etag")]),v._v(" 优先级高于 "),_("code",[v._v("Last-Modified")])]),v._v(" "),_("li",[v._v("强缓存优先级高于协商缓存，若强缓存生效则直接使用强缓存，否则进行协商缓存")])])])}),[],!1,null,null,null);_.default=e.exports}}]);