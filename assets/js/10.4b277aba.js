(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{401:function(t,s,a){"use strict";a.r(s);var r=a(1),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1-css盒子模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-css盒子模型"}},[t._v("#")]),t._v(" 1. CSS盒子模型")]),t._v(" "),s("p",[t._v("把 CSS 盒子模型分为content、padding、border 和 margin 四部分，可当成生活中的盒子去理解。content 即是盒子的内容，padding 是包裹在内容外边的填充物，border是盒子的边框，margin是盒子与其他盒子之间的距离。"),s("br"),t._v("\n盒子模型可分为两种：标准盒子模型（W3C盒模型）和怪异盒模型（IE盒模型）"),s("br"),t._v("\n标准盒：设定的 height 和 width 表示的是内容的大小；"),s("br"),t._v("\n怪异盒：设定的 height 和 width 表示的是内容+内边距（padding）+边框（border）的大小"),s("br"),t._v("\n可通过 CSS3 中的属性 box-sizing 指定盒子模型"),s("br"),t._v("\nbox-sizing: content-size; ———— 标准盒"),s("br"),t._v("\nbox-sizing: border-size; ———— 怪异盒")]),t._v(" "),s("h2",{attrs:{id:"_2-选择器类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-选择器类型"}},[t._v("#")]),t._v(" 2. "),s("a",{attrs:{href:"https://www.nowcoder.com/ta/review-frontend/review?tpId=80&tqId=29721&query=css&asc=true&order=&page=2",target:"_blank",rel:"noopener noreferrer"}},[t._v("选择器类型"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"_3-css优先级、权重计算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-css优先级、权重计算"}},[t._v("#")]),t._v(" 3. CSS优先级、权重计算")]),t._v(" "),s("h2",{attrs:{id:"_4-link-和-important-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-link-和-important-的区别"}},[t._v("#")]),t._v(" 4. link 和 @important 的区别")]),t._v(" "),s("p",[t._v("1）link属于HTML标签，而@important是由CSS提供的；"),s("br"),t._v("\n2）页面加载时，link会被同时加载，而@important引用的CSS会在页面加载完成后再加载；"),s("br"),t._v("\n3）link无兼容问题，@important 在IE5以上才支持；"),s("br"),t._v("\n4）link方式引入的样式优先级高于@important")]),t._v(" "),s("h2",{attrs:{id:"_5-为什么要初始化-css-标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-为什么要初始化-css-标签"}},[t._v("#")]),t._v(" 5. 为什么要初始化 CSS 标签")]),t._v(" "),s("p",[t._v("因为浏览器的兼容问题，不同浏览器对一些标签的默认值是不同的，如果不进行初始化，会导致页面显示出现问题。")]),t._v(" "),s("h2",{attrs:{id:"_6-css3-新增特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-css3-新增特性"}},[t._v("#")]),t._v(" 6. "),s("a",{attrs:{href:"https://www.cnblogs.com/xkweb/p/5862612.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSS3 新增特性"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"_7-css动画和-js-动画的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-css动画和-js-动画的区别"}},[t._v("#")]),t._v(" 7. CSS动画和 JS 动画的区别")]),t._v(" "),s("p",[t._v("渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，这时整个CSS动画得以在compositor trhead完成（而js动画则会在main thread执行，然后出发compositor thread进行下一步操作），特别注意的是如果改变transform和opacity是不会layout或者paint的。")]),t._v(" "),s("p",[t._v("区别："),s("br"),t._v("\n1）功能涵盖面，js比css大"),s("br"),t._v("\n2）实现/重构难度不一，CSS3比js更加简单，性能跳优方向固定"),s("br"),t._v("\n3）对帧速表现不好的低版本浏览器，css3可以做到自然降级"),s("br"),t._v("\n4）css动画有天然事件支持"),s("br"),t._v("\n5）css3有兼容性问题")]),t._v(" "),s("h2",{attrs:{id:"_8-css-动画相关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-css-动画相关"}},[t._v("#")]),t._v(" 8. CSS 动画相关")]),t._v(" "),s("p",[t._v("硬币旋转、绘制三角形、绘制正方体")]),t._v(" "),s("h2",{attrs:{id:"_9-css的刻度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-css的刻度"}},[t._v("#")]),t._v(" 9. CSS的刻度")]),t._v(" "),s("h2",{attrs:{id:"_10-css-定位-position"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-css-定位-position"}},[t._v("#")]),t._v(" 10. CSS 定位（position）")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("static")]),t._v("\n默认值，不脱离正常的文档流")]),t._v(" "),s("li",[s("strong",[t._v("relative")]),t._v("\n相对定位，相对自己原先位置，原来的位置仍会占据空间")]),t._v(" "),s("li",[s("strong",[t._v("absolute")]),t._v("\n绝对定位，相对第一个不为 static 的祖先节点偏移，脱离正常文档流")]),t._v(" "),s("li",[s("strong",[t._v("fixed")]),t._v("\n固定定位，相对于浏览器窗口偏移，脱离正常文档流")]),t._v(" "),s("li",[s("strong",[t._v("sticky")]),t._v("\n根据滚动位置在相对定位和固定定位转换，起初是相对定位，但窗口滚动到定义的偏移位置后则变成固定定位")])]),t._v(" "),s("h2",{attrs:{id:"_11-css-布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-css-布局"}},[t._v("#")]),t._v(" 11. "),s("a",{attrs:{href:"https://mp.weixin.qq.com/s/6pNcDBDqZzOJP46V6eZJeg",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSS 布局"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"_12-盒子塌陷是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-盒子塌陷是什么"}},[t._v("#")]),t._v(" 12. 盒子塌陷是什么？")]),t._v(" "),s("p",[t._v("本应该在父盒子内部的元素跑到了外部。")]),t._v(" "),s("p",[t._v("关于盒子塌陷的几种解决方法")]),t._v(" "),s("p",[t._v("（1）最简单，直接，粗暴的方法就是盒子大小写死，给每个盒子设定固定的width和height，直到合适为止，这样的好处是简单方便，兼容性好，适合只改动少量内容不涉及盒子排布的版面。缺点是非自适应，浏览器的窗口大小直接影响用户体验。")]),t._v(" "),s("p",[t._v("（2）给外部的父盒子也添加浮动，让其也脱离标准文档流，这种方法方便，但是对页面的布局不是很友好，不易维护。")]),t._v(" "),s("p",[t._v("（3）给父盒子添加overflow属性。")]),t._v(" "),s("p",[t._v("overflow:auto; 有可能出现滚动条，影响美观。")]),t._v(" "),s("p",[t._v("overflow:hidden; 可能会带来内容不可见的问题。")]),t._v(" "),s("p",[t._v("（4）父盒子里最下方引入清除浮动块。最简单的有："),s("br"),t._v(" "),s("code",[t._v('<br style="clear:both;"/>')]),s("br"),t._v("\n有很多人是这么解决的，但是我们并不推荐，因为其引入了不必要的冗余元素 。")]),t._v(" "),s("p",[t._v("(5)用after伪元素清除浮动")]),t._v(" "),s("p",[t._v("给外部盒子的after伪元素设置clear属性，再隐藏它")]),t._v(" "),s("p",[t._v("这其实是对空盒子方案的改进，一种纯CSS的解决方案，不用引入冗余元素。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("clearfix "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("zoom"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("clearfix"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("before"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("clearfix"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("after "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("display")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \nline"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("height"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("content")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("clearfix"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("after "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("clear")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" both"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这也是bootstrap框架采用的清除浮动的方法。")]),t._v(" "),s("p",[t._v("这是一种纯CSS的解决浮动造成盒子塌陷方法，没有引入任何冗余元素，推荐使用此方法来解决CSS盒子塌陷。")]),t._v(" "),s("p",[t._v("备注：第五种方法虽好，但是低版本IE不兼容，具体选择哪种解决方法，可根据实际情况决定。")]),t._v(" "),s("p",[t._v("(6) 给父盒子添加border")]),t._v(" "),s("p",[t._v("(7) 给父盒子设置padding-top")]),t._v(" "),s("p",[s("strong",[t._v("为什么会出现盒子塌陷？")]),s("br"),t._v("\n当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是CSS高度塌陷。")]),t._v(" "),s("h2",{attrs:{id:"_13-bfc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-bfc"}},[t._v("#")]),t._v(" 13. BFC")]),t._v(" "),s("p",[t._v("BFC (Block Formatting Context) 即块级格式化上下文，决定元素如何对其内容进行定位，以及和其他元素的关系和相互作用。也就是 BFC 是一个独立的布局空间，里面的内容不会影响到外部的布局。")]),t._v(" "),s("p",[t._v("触发 BFC 的条件：")]),t._v(" "),s("ol",[s("li",[t._v("float 的值不为 none;")]),t._v(" "),s("li",[t._v("position 的值不为 static 或 relative;")]),t._v(" "),s("li",[t._v("display 的值为 table、fix、inline-block;")]),t._v(" "),s("li",[t._v("overflow 的值不为 visible")])]),t._v(" "),s("p",[t._v("BFC 规则：")]),t._v(" "),s("ol",[s("li",[t._v("内部的 Box 会在垂直方向一个接着一个放置;")]),t._v(" "),s("li",[t._v("内部的元素不会影响外部布局;")]),t._v(" "),s("li",[t._v("计算 BFC 高度时浮动元素也会被计算;")]),t._v(" "),s("li",[t._v("同一个 BFC 内的 margin 会出现重叠现象")])]),t._v(" "),s("h2",{attrs:{id:"_14-flex-与-grid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-flex-与-grid"}},[t._v("#")]),t._v(" 14. Flex 与 Grid")]),t._v(" "),s("p",[s("code",[t._v("flex")]),t._v(" 即弹性布局,是一种一维的布局方式，容器中默认存在两条轴，主轴和交叉轴，呈90度关系。项目默认沿主轴排列，通过 "),s("code",[t._v("flex-direction")]),t._v(" 来决定主轴的方向。")]),t._v(" "),s("ul",[s("li",[t._v("容器属性\n"),s("ul",[s("li",[s("code",[t._v("flex-direction:")]),t._v(" row/ row-reverse/ column/ column-reverse"),s("br"),t._v("\n定义主轴的方向")]),t._v(" "),s("li",[s("code",[t._v("justify-content:")]),t._v(" center/ flex-start/ flex-end/ space-between/ space-around/ space-evenly"),s("br"),t._v("\n定义主轴方向上的对齐方式")]),t._v(" "),s("li",[s("code",[t._v("align-items:")]),t._v(" stretch/ center/ flex-start/ flex-end/ baseline"),s("br"),t._v("\n定义交叉轴方向上的对齐方式")]),t._v(" "),s("li",[s("code",[t._v("flex-wrap:")]),t._v(" nowrap/ warp/ wrap-reverse"),s("br"),t._v("\n定义项目如何换行，默认项目都排列在一条线上不换行")]),t._v(" "),s("li",[s("code",[t._v("flex-flow:")]),t._v(" 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap")])])]),t._v(" "),s("li",[t._v("项目属性\n"),s("ul",[s("li",[s("code",[t._v("order:")]),t._v(" 项目排列顺序，数字越小排越前，默认为0")]),t._v(" "),s("li",[s("code",[t._v("flex-grow:")]),t._v(" 定义项目放大比例")]),t._v(" "),s("li",[s("code",[t._v("flex-shrink:")]),t._v(" 定义项目缩小比例")]),t._v(" "),s("li",[s("code",[t._v("flex-basis:")]),t._v(" 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小")]),t._v(" "),s("li",[s("code",[t._v("flex:")]),t._v(" flex-grow + flex-shrink + flex-basis")]),t._v(" "),s("li",[s("code",[t._v("align-self:")]),t._v("  默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。")])])])]),t._v(" "),s("p",[t._v("利用 flex 可以很简单地实现元素居中对齐，两列、三列自适应布局。flex 多用于移动端和小程序。")]),t._v(" "),s("p",[s("code",[t._v("Grid")]),t._v(" 布局即网格布局，是一个二维的布局方式，由纵横相交的两组网格线形成的框架性布局结构，能够同时处理行与列。"),s("br"),t._v("\n擅长将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系。"),s("br"),t._v("\nIE10 以下不支持，手机端适配性较差")]),t._v(" "),s("h2",{attrs:{id:"_15-回流和重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-回流和重绘"}},[t._v("#")]),t._v(" 15. 回流和重绘")]),t._v(" "),s("p",[t._v("回流(重排): 当页面布局、元素的几何属性或元素内部的文字结构发生变化，导致页面需要重新构建，就会发生回流;"),s("br"),t._v("\n重绘: 当页面的布局、元素几何结构不变，而其他如颜色等样式发生变化时，就会发生重绘;"),s("br"),t._v("\n页面第一次构建时一定会触发一次回流和重绘"),s("br"),t._v("\n回流一定会触发重绘，重绘不一定会触发回流")]),t._v(" "),s("p",[t._v("如何避免重绘或者重排？")]),t._v(" "),s("ol",[s("li",[t._v("集中改变样式，不要一条一条地修改 DOM 的样式。")]),t._v(" "),s("li",[t._v("不要把 DOM 结点的属性值放在循环里当成循环里的变量。")]),t._v(" "),s("li",[t._v("为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。")]),t._v(" "),s("li",[t._v("不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。")]),t._v(" "),s("li",[t._v("尽量只修改position：absolute或fixed元素，对其他元素影响不大")]),t._v(" "),s("li",[t._v("动画开始GPU加速，translate使用3D变化")]),t._v(" "),s("li",[t._v("提升为合成层\n将元素提升为合成层有以下优点：")])]),t._v(" "),s("ul",[s("li",[t._v("合成层的位图，会交由 GPU 合成，比 CPU 处理要快")]),t._v(" "),s("li",[t._v("当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层")]),t._v(" "),s("li",[t._v("对于 transform 和 opacity 效果，不会触发 layout 和 paint")])]),t._v(" "),s("h2",{attrs:{id:"_16-最小字体-怎么设置更小"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-最小字体-怎么设置更小"}},[t._v("#")]),t._v(" 16. 最小字体？怎么设置更小")]),t._v(" "),s("p",[t._v("问题：使用font-size设置字体，最小只到12px，设置小于12字体也不会再缩小了。")]),t._v(" "),s("p",[t._v("原因：Chrome 以及 Chromium 内核的浏览器在中文语言下最小字体只能是12px")]),t._v(" "),s("p",[t._v("解决方案：使用 "),s("code",[t._v("transform: scale()")]),t._v(" 缩放属性实现")]),t._v(" "),s("div",{staticClass:"language-css extra-class"},[s("pre",{pre:!0,attrs:{class:"language-css"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".d1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 12px"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("transform")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("scale")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("0.5"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 缩放为0.5，即6px */")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("transform-origin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 0 0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 左对齐 */")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);